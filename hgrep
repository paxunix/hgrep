#!/usr/bin/perl -w

# Run grep on each input, but always output the header (i.e. first) line of
# each input.
#
# Works as much like grep as possible.

use strict;

# Peel file(like) arguments off the end since we have to read the header
# line from and pass them individually to grep.

my @files;
while (defined($ARGV[-1]) && -e $ARGV[-1])
{
    push(@files, pop(@ARGV));
}

# Reading from stdin is handled specially because there is never a leading
# filename.
if (! -t STDIN)
{
    open(my $grep, "|-", "grep", @ARGV) or
        die("Failed opening grep pipe: $!");

    while (<STDIN>)
    {
        print("\n$_") if ($. == 1);     # always output first line
        print($grep $_);        # send the rest to grep
    }

    close($grep);
    exit($?);
}

my $includeFilenames = (@files > 1 || grep { $_ eq "-H" } @ARGV);
my $errors = 0;

for my $file (@files)
{
    open(my $fh, $file) or
        die("Failed to open $file for read: $!");

    my $header = <$fh>;
    close($fh);
    if (defined($header))
    {
        open(my $grep, "-|",
            "grep", ($includeFilenames ? "-H" : ()), @ARGV, $file) or
                die("Failed to open grep pipe for read: $!");

        my $showedHeader = 0;
        while (<$grep>)
        {
            # As soon as we've seen one matched line from grep, output the
            # header.
            if (!$showedHeader)
            {
                print(($includeFilenames ? "$file:" : ()), $header);
                $showedHeader = 1;
            }

            print;
        }

        $errors |= close($grep);
    }
}

exit($errors);

# XXX:  really should have some kind of tests for this
